1
00:00:00,006 --> 00:00:02,007
- Testing is a programming basic

2
00:00:02,007 --> 00:00:05,001
but many people still struggle with it.

3
00:00:05,001 --> 00:00:07,001
Testing is even more critical than ever

4
00:00:07,001 --> 00:00:08,005
as you increase automation

5
00:00:08,005 --> 00:00:11,003
and the speed of change in your systems.

6
00:00:11,003 --> 00:00:13,002
If there's only one thing that you take away

7
00:00:13,002 --> 00:00:14,004
from this course,

8
00:00:14,004 --> 00:00:17,009
it's that you should always test your infrastructure.

9
00:00:17,009 --> 00:00:19,005
I'm an old school CIS admin,

10
00:00:19,005 --> 00:00:21,005
and keeping production systems up and running

11
00:00:21,005 --> 00:00:23,005
is job number one.

12
00:00:23,005 --> 00:00:26,006
I understand a newfangled thing like continuous integration

13
00:00:26,006 --> 00:00:28,006
and deployment might make you nervous,

14
00:00:28,006 --> 00:00:30,003
but it's the single biggest breakthrough

15
00:00:30,003 --> 00:00:33,004
in systems quality in decades.

16
00:00:33,004 --> 00:00:36,003
Before this, the state-of-the-art was having a checklist

17
00:00:36,003 --> 00:00:38,009
that you'd manually go down time after time

18
00:00:38,009 --> 00:00:40,007
for each system you're changing.

19
00:00:40,007 --> 00:00:43,004
If you're lucky, you'd run it on a test system

20
00:00:43,004 --> 00:00:46,001
that may or may not be like production.

21
00:00:46,001 --> 00:00:50,002
And as the kids nowadays say, "That ain't it."

22
00:00:50,002 --> 00:00:53,004
Testing infrastructure is similar to testing code.

23
00:00:53,004 --> 00:00:55,009
There's a concept called the testing pyramid

24
00:00:55,009 --> 00:00:58,002
that describes a generally successful

25
00:00:58,002 --> 00:01:00,004
and efficient approach to testing.

26
00:01:00,004 --> 00:01:03,007
At the base of the pyramid is unit testing.

27
00:01:03,007 --> 00:01:06,000
Unit testing is code level testing

28
00:01:06,000 --> 00:01:08,004
and takes the smallest testable parts

29
00:01:08,004 --> 00:01:12,005
or functions in your code and verifies their execution.

30
00:01:12,005 --> 00:01:16,007
Formatters and linters also fall into this category.

31
00:01:16,007 --> 00:01:19,004
You want to spend most of your time on unit tests.

32
00:01:19,004 --> 00:01:21,000
They're fast and simple,

33
00:01:21,000 --> 00:01:22,006
and they're your first line of defense

34
00:01:22,006 --> 00:01:24,007
against simple errors.

35
00:01:24,007 --> 00:01:28,005
In the previous chapter, we showed you some Terraform code.

36
00:01:28,005 --> 00:01:30,009
Terraform has basic built-in tools,

37
00:01:30,009 --> 00:01:34,009
like Terraform validate and Terraform format, dash, check

38
00:01:34,009 --> 00:01:38,001
that ensure your Terraform is basically executable.

39
00:01:38,001 --> 00:01:41,001
And there's a great open source tool called TFLint

40
00:01:41,001 --> 00:01:44,006
that goes deeper into likely errors in your code.

41
00:01:44,006 --> 00:01:47,002
Then you can write more specific unit tests

42
00:01:47,002 --> 00:01:50,007
by using Terraform plan, which is a dry run

43
00:01:50,007 --> 00:01:53,000
that shows what Terraform thinks it should do

44
00:01:53,000 --> 00:01:55,006
from your description, but without needing to touch

45
00:01:55,006 --> 00:01:57,007
any external infrastructure.

46
00:01:57,007 --> 00:02:00,001
It generates a big load of JSON output

47
00:02:00,001 --> 00:02:03,004
of Terraform's intended actions that you can parse

48
00:02:03,004 --> 00:02:07,002
and look for things that you want to ensure in place.

49
00:02:07,002 --> 00:02:09,003
Since these tests are quick and easy,

50
00:02:09,003 --> 00:02:11,005
you can run a bunch of different scenarios

51
00:02:11,005 --> 00:02:13,004
and configuration options

52
00:02:13,004 --> 00:02:16,002
to make sure that your infrastructure code behaves correctly

53
00:02:16,002 --> 00:02:18,000
for each combination.

54
00:02:18,000 --> 00:02:21,002
The next level of testing is integration testing.

55
00:02:21,002 --> 00:02:24,006
Integration testing is at the heart of infrastructure.

56
00:02:24,006 --> 00:02:27,008
Sure, we can test the code that builds the systems,

57
00:02:27,008 --> 00:02:32,001
however, the actual build and run time has to be validated.

58
00:02:32,001 --> 00:02:33,008
Integration testing focuses

59
00:02:33,008 --> 00:02:37,005
on testing several components together.

60
00:02:37,005 --> 00:02:40,008
Integration testing takes more time and resources,

61
00:02:40,008 --> 00:02:42,006
but it's obviously more effective

62
00:02:42,006 --> 00:02:45,005
at validating actual operation than unit tests,

63
00:02:45,005 --> 00:02:47,006
so you want to do it after the unit tests

64
00:02:47,006 --> 00:02:49,009
will have already passed.

65
00:02:49,009 --> 00:02:52,005
In Terraform, the way you do an integration test

66
00:02:52,005 --> 00:02:56,002
is to Terraform apply your code in a test environment

67
00:02:56,002 --> 00:02:58,001
and inspect the resulting system

68
00:02:58,001 --> 00:03:00,003
to make sure it's configured all right.

69
00:03:00,003 --> 00:03:01,004
Are the servers running?

70
00:03:01,004 --> 00:03:04,002
Are the IP addresses correct, and so on?

71
00:03:04,002 --> 00:03:08,001
And then you can just Terraform destroy it when you're done.

72
00:03:08,001 --> 00:03:11,000
There are Terraform test frameworks like Terratest

73
00:03:11,000 --> 00:03:14,003
and Kitchen-Terraform that can help you with this.

74
00:03:14,003 --> 00:03:16,004
End-to-end testing goes a step farther

75
00:03:16,004 --> 00:03:19,002
to validate the entire running system.

76
00:03:19,002 --> 00:03:22,005
Infrastructure and application code testing merge here.

77
00:03:22,005 --> 00:03:25,003
End-to-end tests exercise the APIs and UIs

78
00:03:25,003 --> 00:03:26,009
of the resulting system

79
00:03:26,009 --> 00:03:30,002
to make sure it's behaving in the way it should.

80
00:03:30,002 --> 00:03:32,001
End-to-end testing is slow

81
00:03:32,001 --> 00:03:34,005
and it has to have a fully constructed system

82
00:03:34,005 --> 00:03:37,008
with applications and data and everything.

83
00:03:37,008 --> 00:03:39,009
It also usually requires a lot of maintenance

84
00:03:39,009 --> 00:03:41,004
and updating over time,

85
00:03:41,004 --> 00:03:44,004
because your overall system changes a lot more often

86
00:03:44,004 --> 00:03:47,000
than any single component does.

87
00:03:47,000 --> 00:03:49,005
As a result, you want to keep the amount of these tests

88
00:03:49,005 --> 00:03:53,003
to a bare minimum and test only the critical path.

89
00:03:53,003 --> 00:03:56,002
But it's the absolutely best test,

90
00:03:56,002 --> 00:03:59,002
because it emulates the actual user experience

91
00:03:59,002 --> 00:04:00,001
instead of assuming

92
00:04:00,001 --> 00:04:01,008
that the building's going to be solid

93
00:04:01,008 --> 00:04:04,008
just because each brick is.

94
00:04:04,008 --> 00:04:07,007
Then you can add in manual acceptance testing,

95
00:04:07,007 --> 00:04:11,006
security testing, performance testing, and more.

96
00:04:11,006 --> 00:04:13,007
I know that sounds like a lot,

97
00:04:13,007 --> 00:04:16,004
but the beauty of it is it can be completely automated

98
00:04:16,004 --> 00:04:18,009
in your build pipeline.

99
00:04:18,009 --> 00:04:22,002
I ran a team at AT&T Cybersecurity that was responsible

100
00:04:22,002 --> 00:04:23,009
for all of our cloud infrastructure,

101
00:04:23,009 --> 00:04:27,000
for our SaaS security management product.

102
00:04:27,000 --> 00:04:29,004
We had a Packer and Terraform pipeline

103
00:04:29,004 --> 00:04:33,003
that ran out of an Atlassian Bamboo CI CD system.

104
00:04:33,003 --> 00:04:36,000
On code check-in, it would run unit tests.

105
00:04:36,000 --> 00:04:37,002
Then if those passed,

106
00:04:37,002 --> 00:04:38,009
it would use it to build infrastructure

107
00:04:38,009 --> 00:04:41,006
in a test environment and do integration tests.

108
00:04:41,006 --> 00:04:43,009
And if that worked, it would run end-to-end tests

109
00:04:43,009 --> 00:04:46,007
using Robot Framework and Selenium.

110
00:04:46,007 --> 00:04:48,006
If those passed, it would queue it up

111
00:04:48,006 --> 00:04:50,008
and prepare for a production deployment,

112
00:04:50,008 --> 00:04:53,005
which would run out of our Rundeck orchestration tool

113
00:04:53,005 --> 00:04:55,005
after any manual acceptance testing

114
00:04:55,005 --> 00:04:59,006
the product team was doing for new features in that release.

115
00:04:59,006 --> 00:05:02,004
We had performance and cross browser testing.

116
00:05:02,004 --> 00:05:05,000
They were quite slow, so they ran on a schedule,

117
00:05:05,000 --> 00:05:08,002
not on each code check-in.

118
00:05:08,002 --> 00:05:09,009
I can't stress this enough.

119
00:05:09,009 --> 00:05:12,009
If you're doing infrastructure as code without testing,

120
00:05:12,009 --> 00:05:14,006
you're doing it wrong.

121
00:05:14,006 --> 00:05:17,007
You can burn down a global system very quickly

122
00:05:17,007 --> 00:05:20,002
through automation if not done safely.

123
00:05:20,002 --> 00:05:21,007
As my Uncle Ben once told me,

124
00:05:21,007 --> 00:05:25,006
"With great power comes great responsibility."

125
00:05:25,006 --> 00:05:28,000
I miss you Uncle Ben!

